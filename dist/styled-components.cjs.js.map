{"version":3,"file":"styled-components.cjs.js","sources":["../src/models/StyleTags.js","../src/models/Keyframes.js","../src/models/ThemeProvider.js","../src/models/StyleSheetManager.js","../src/models/StyledComponent.js","../src/models/ComponentStyle.js","../src/constructors/styled.js","../src/constructors/keyframes.js","../src/models/GlobalStyle.js","../src/constructors/createGlobalStyle.js"],"sourcesContent":["// @flow\n/* eslint-disable flowtype/object-type-delimiter */\n/* eslint-disable react/prop-types */\n\nimport React, { type Element } from 'react'\nimport {\n  IS_BROWSER,\n  DISABLE_SPEEDY,\n  SC_ATTR,\n  SC_VERSION_ATTR,\n} from '../constants'\nimport StyledError from '../utils/error'\nimport { type ExtractedComp } from '../utils/extractCompsFromCSS'\nimport { splitByRules } from '../utils/stringifyRules'\nimport getNonce from '../utils/nonce'\nimport once from '../utils/once'\n\nimport {\n  type Names,\n  addNameForId,\n  resetIdNames,\n  hasNameForId,\n  stringifyNames,\n  cloneNames,\n} from '../utils/styleNames'\n\nimport {\n  sheetForTag,\n  safeInsertRule,\n  deleteRules,\n} from '../utils/insertRuleHelpers'\n\ndeclare var __VERSION__: string\n\nexport interface Tag<T> {\n  // $FlowFixMe: Doesn't seem to accept any combination w/ HTMLStyleElement for some reason\n  styleTag: HTMLStyleElement | null;\n  /* lists all ids of the tag */\n  getIds(): string[];\n  /* checks whether `name` is already injected for `id` */\n  hasNameForId(id: string, name: string): boolean;\n  /* inserts a marker to ensure the id's correct position in the sheet */\n  insertMarker(id: string): T;\n  /* inserts rules according to the ids markers */\n  insertRules(id: string, cssRules: string[], name: ?string): void;\n  /* removes all rules belonging to the id, keeping the marker around */\n  removeRules(id: string): void;\n  css(): string;\n  toHTML(additionalAttrs: ?string): string;\n  toElement(): Element<*>;\n  clone(): Tag<T>;\n}\n\n/* this marker separates component styles and is important for rehydration */\nconst makeTextMarker = id => `\\n/* sc-component-id: ${id} */\\n`\n\n/* add up all numbers in array up until and including the index */\nconst addUpUntilIndex = (sizes: number[], index: number): number => {\n  let totalUpToIndex = 0\n  for (let i = 0; i <= index; i += 1) {\n    totalUpToIndex += sizes[i]\n  }\n\n  return totalUpToIndex\n}\n\n/* create a new style tag after lastEl */\nconst makeStyleTag = (\n  target: ?HTMLElement,\n  tagEl: ?Node,\n  insertBefore: ?boolean\n) => {\n  const el = document.createElement('style')\n  el.setAttribute(SC_ATTR, '')\n  el.setAttribute(SC_VERSION_ATTR, __VERSION__)\n\n  const nonce = getNonce()\n  if (nonce) {\n    el.setAttribute('nonce', nonce)\n  }\n\n  /* Work around insertRule quirk in EdgeHTML */\n  el.appendChild(document.createTextNode(''))\n\n  if (target && !tagEl) {\n    /* Append to target when no previous element was passed */\n    target.appendChild(el)\n  } else {\n    if (!tagEl || !target || !tagEl.parentNode) {\n      throw new StyledError(6)\n    }\n\n    /* Insert new style tag after the previous one */\n    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling)\n  }\n\n  return el\n}\n\n/* takes a css factory function and outputs an html styled tag factory */\nconst wrapAsHtmlTag = (css: () => string, names: Names) => (\n  additionalAttrs: ?string\n): string => {\n  const nonce = getNonce()\n  const attrs = [\n    nonce && `nonce=\"${nonce}\"`,\n    `${SC_ATTR}=\"${stringifyNames(names)}\"`,\n    `${SC_VERSION_ATTR}=\"${__VERSION__}\"`,\n    additionalAttrs,\n  ]\n\n  const htmlAttr = attrs.filter(Boolean).join(' ')\n  return `<style ${htmlAttr}>${css()}</style>`\n}\n\n/* takes a css factory function and outputs an element factory */\nconst wrapAsElement = (css: () => string, names: Names) => () => {\n  const props = {\n    [SC_ATTR]: stringifyNames(names),\n    [SC_VERSION_ATTR]: __VERSION__,\n  }\n\n  const nonce = getNonce()\n  if (nonce) {\n    // $FlowFixMe\n    props.nonce = nonce\n  }\n\n  // eslint-disable-next-line react/no-danger\n  return <style {...props} dangerouslySetInnerHTML={{ __html: css() }} />\n}\n\nconst getIdsFromMarkersFactory = (markers: Object) => (): string[] =>\n  Object.keys(markers)\n\n/* speedy tags utilise insertRule */\nconst makeSpeedyTag = (\n  el: HTMLStyleElement,\n  getImportRuleTag: ?() => Tag<any>\n): Tag<number> => {\n  const names: Names = (Object.create(null): Object)\n  const markers = Object.create(null)\n  const sizes: number[] = []\n\n  const extractImport = getImportRuleTag !== undefined\n  /* indicates whther getImportRuleTag was called */\n  let usedImportRuleTag = false\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    markers[id] = sizes.length\n    sizes.push(0)\n    resetIdNames(names, id)\n\n    return markers[id]\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    const sheet = sheetForTag(el)\n    const insertIndex = addUpUntilIndex(sizes, marker)\n\n    let injectedRules = 0\n    const importRules = []\n    const cssRulesSize = cssRules.length\n\n    for (let i = 0; i < cssRulesSize; i += 1) {\n      const cssRule = cssRules[i]\n      let mayHaveImport = extractImport /* @import rules are reordered to appear first */\n      if (mayHaveImport && cssRule.indexOf('@import') !== -1) {\n        importRules.push(cssRule)\n      } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {\n        mayHaveImport = false\n        injectedRules += 1\n      }\n    }\n\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true\n      // $FlowFixMe\n      getImportRuleTag().insertRules(`${id}-import`, importRules)\n    }\n\n    sizes[marker] += injectedRules /* add up no of injected rules */\n    addNameForId(names, id, name)\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n\n    const size = sizes[marker]\n    const sheet = sheetForTag(el)\n    const removalIndex = addUpUntilIndex(sizes, marker)\n    deleteRules(sheet, removalIndex, size)\n    sizes[marker] = 0\n    resetIdNames(names, id)\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(`${id}-import`)\n    }\n  }\n\n  const css = () => {\n    const { cssRules } = sheetForTag(el)\n    let str = ''\n\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      str += makeTextMarker(id)\n      const marker = markers[id]\n      const end = addUpUntilIndex(sizes, marker)\n      const size = sizes[marker]\n      for (let i = end - size; i < end; i += 1) {\n        const rule = cssRules[i]\n        if (rule !== undefined) {\n          str += rule.cssText\n        }\n      }\n    }\n\n    return str\n  }\n\n  return {\n    styleTag: el,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    css,\n    toHTML: wrapAsHtmlTag(css, names),\n    toElement: wrapAsElement(css, names),\n    clone() {\n      throw new StyledError(5)\n    },\n  }\n}\n\nconst makeTextNode = id => document.createTextNode(makeTextMarker(id))\n\nconst makeBrowserTag = (\n  el: HTMLStyleElement,\n  getImportRuleTag: ?() => Tag<any>\n): Tag<Text> => {\n  const names = (Object.create(null): Object)\n  const markers = Object.create(null)\n\n  const extractImport = getImportRuleTag !== undefined\n\n  /* indicates whther getImportRuleTag was called */\n  let usedImportRuleTag = false\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    markers[id] = makeTextNode(id)\n    el.appendChild(markers[id])\n    names[id] = Object.create(null)\n\n    return markers[id]\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    const importRules = []\n    const cssRulesSize = cssRules.length\n\n    for (let i = 0; i < cssRulesSize; i += 1) {\n      const rule = cssRules[i]\n      let mayHaveImport = extractImport\n      if (mayHaveImport && rule.indexOf('@import') !== -1) {\n        importRules.push(rule)\n      } else {\n        mayHaveImport = false\n        const separator = i === cssRulesSize - 1 ? '' : ' '\n        marker.appendData(`${rule}${separator}`)\n      }\n    }\n    addNameForId(names, id, name)\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true\n      // $FlowFixMe\n      getImportRuleTag().insertRules(`${id}-import`, importRules)\n    }\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n\n    /* create new empty text node and replace the current one */\n    const newMarker = makeTextNode(id)\n    el.replaceChild(newMarker, marker)\n    markers[id] = newMarker\n    resetIdNames(names, id)\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(`${id}-import`)\n    }\n  }\n\n  const css = () => {\n    let str = ''\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      str += markers[id].data\n    }\n    return str\n  }\n  return {\n    clone() {\n      throw new StyledError(5)\n    },\n    css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    styleTag: el,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names),\n  }\n}\n\nconst makeServerTagInternal = (namesArg, markersArg): Tag<[string]> => {\n  const names =\n    namesArg === undefined ? (Object.create(null): Object) : namesArg\n  const markers = markersArg === undefined ? Object.create(null) : markersArg\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    return (markers[id] = [''])\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    marker[0] += cssRules.join(' ')\n    addNameForId(names, id, name)\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n    marker[0] = ''\n    resetIdNames(names, id)\n  }\n\n  const css = () => {\n    let str = ''\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      const cssForId = markers[id][0]\n      if (cssForId) {\n        str += makeTextMarker(id) + cssForId\n      }\n    }\n    return str\n  }\n\n  const clone = () => {\n    const namesClone = cloneNames(names)\n    const markersClone = Object.create(null)\n\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      markersClone[id] = [markers[id][0]]\n    }\n\n    return makeServerTagInternal(namesClone, markersClone)\n  }\n\n  const tag = {\n    clone,\n    css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    styleTag: null,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names),\n  }\n\n  return tag\n}\n\nconst makeServerTag = (): Tag<[string]> => makeServerTagInternal()\n\nexport const makeTag = (\n  target: ?HTMLElement,\n  tagEl: ?HTMLStyleElement,\n  forceServer?: boolean,\n  insertBefore?: boolean,\n  getImportRuleTag?: () => Tag<any>\n): Tag<any> => {\n  if (IS_BROWSER && !forceServer) {\n    const el = makeStyleTag(target, tagEl, insertBefore)\n\n    if (DISABLE_SPEEDY) {\n      return makeBrowserTag(el, getImportRuleTag)\n    } else {\n      return makeSpeedyTag(el, getImportRuleTag)\n    }\n  }\n\n  return makeServerTag()\n}\n\n/* wraps a given tag so that rehydration is performed once when necessary */\nexport const makeRehydrationTag = (\n  tag: Tag<any>,\n  els: HTMLStyleElement[],\n  extracted: ExtractedComp[],\n  immediateRehydration: boolean\n): Tag<any> => {\n  /* rehydration function that adds all rules to the new tag */\n  const rehydrate = once(() => {\n    /* add all extracted components to the new tag */\n    for (let i = 0, len = extracted.length; i < len; i += 1) {\n      const { componentId, cssFromDOM } = extracted[i]\n      const cssRules = splitByRules(cssFromDOM)\n      tag.insertRules(componentId, cssRules)\n    }\n\n    /* remove old HTMLStyleElements, since they have been rehydrated */\n    for (let i = 0, len = els.length; i < len; i += 1) {\n      const el = els[i]\n      if (el.parentNode) {\n        el.parentNode.removeChild(el)\n      }\n    }\n  })\n\n  if (immediateRehydration) rehydrate()\n\n  return {\n    ...tag,\n    /* add rehydration hook to insertion methods */\n    insertMarker: id => {\n      rehydrate()\n      return tag.insertMarker(id)\n    },\n    insertRules: (id, cssRules, name) => {\n      rehydrate()\n      return tag.insertRules(id, cssRules, name)\n    },\n  }\n}\n","// @flow\nimport StyleSheet from '../models/StyleSheet'\n\nexport default class Keyframes {\n  id: string\n  name: string\n  rules: Array<string>\n\n  constructor(name: string, rules: Array<string>) {\n    this.name = name\n    this.rules = rules\n\n    this.id = `sc-keyframes-${name}`\n  }\n\n  inject = (styleSheet: StyleSheet) => {\n    if (!styleSheet.hasNameForId(this.id, this.name)) {\n      styleSheet.inject(this.id, this.rules, this.name)\n    }\n  }\n\n  getName() {\n    return this.name\n  }\n}\n","// @flow\nimport React, { createContext, Component, type Element } from 'react'\nimport memoize from 'memoize-one'\nimport StyledError from '../utils/error'\n\nexport type Theme = { [key: string]: mixed }\ntype Props = {\n  children?: Element<any>,\n  theme: Theme | ((outerTheme: Theme) => void),\n}\n\nconst isFunction = test => typeof test === 'function'\n\nconst ThemeContext = createContext()\n\nexport const ThemeConsumer = ThemeContext.Consumer\n\n/**\n * Provide a theme to an entire react component tree via context\n */\nexport default class ThemeProvider extends Component<Props> {\n  getContext: (\n    theme: Theme | ((outerTheme: Theme) => void),\n    outerTheme?: Theme\n  ) => Theme\n\n  constructor(props: Props) {\n    super(props)\n    this.getContext = memoize(this.getContext.bind(this))\n  }\n\n  render() {\n    const { children, theme } = this.props\n\n    if (!children) {\n      return null\n    }\n\n    return (\n      <ThemeContext.Consumer>\n        {(outerTheme?: Theme) => {\n          const context = this.getContext(theme, outerTheme)\n\n          return (\n            <ThemeContext.Provider value={context}>\n              {React.Children.only(children)}\n            </ThemeContext.Provider>\n          )\n        }}\n      </ThemeContext.Consumer>\n    )\n  }\n\n  // Get the theme from the props, supporting both (outerTheme) => {} as well as object notation\n  getTheme(theme: (outerTheme: ?Theme) => void, outerTheme: ?Theme) {\n    if (isFunction(theme)) {\n      const mergedTheme = theme(outerTheme)\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (mergedTheme === null ||\n          Array.isArray(mergedTheme) ||\n          typeof mergedTheme !== 'object')\n      ) {\n        throw new StyledError(7)\n      }\n\n      return mergedTheme\n    }\n\n    if (theme === null || Array.isArray(theme) || typeof theme !== 'object') {\n      throw new StyledError(8)\n    }\n\n    return { ...outerTheme, ...(theme: Theme) }\n  }\n\n  getContext(theme: (outerTheme: ?Theme) => void, outerTheme?: Theme) {\n    return this.getTheme(theme, outerTheme)\n  }\n}\n","// @flow\nimport React, { createContext, Component, type Element } from 'react'\nimport PropTypes from 'prop-types'\nimport memoize from 'memoize-one'\nimport StyleSheet from './StyleSheet'\nimport ServerStyleSheet from './ServerStyleSheet'\nimport StyledError from '../utils/error'\n\ntype Props = {\n  children?: Element<any>,\n  sheet?: StyleSheet,\n  target?: HTMLElement,\n}\n\nconst StyleSheetContext = createContext()\n\nexport const StyleSheetConsumer = StyleSheetContext.Consumer\n\nexport default class StyleSheetManager extends Component<Props> {\n  static propTypes = {\n    sheet: PropTypes.oneOfType([\n      PropTypes.instanceOf(StyleSheet),\n      PropTypes.instanceOf(ServerStyleSheet),\n    ]),\n    target: PropTypes.shape({\n      appendChild: PropTypes.func.isRequired,\n    }),\n  }\n\n  getContext: (sheet: ?StyleSheet, target: ?HTMLElement) => StyleSheet\n\n  constructor(props: Props) {\n    super(props)\n    this.getContext = memoize(this.getContext)\n  }\n\n  getContext(sheet: ?StyleSheet, target: ?HTMLElement) {\n    if (sheet) {\n      return sheet\n    } else if (target) {\n      return new StyleSheet(target)\n    } else {\n      throw new StyledError(4)\n    }\n  }\n\n  render() {\n    const { children, sheet, target } = this.props\n    const context = this.getContext(sheet, target)\n    return (\n      <StyleSheetContext.Provider value={context}>\n        {React.Children.only(children)}\n      </StyleSheetContext.Provider>\n    )\n  }\n}\n","// @flow\n\nimport validAttr from '@emotion/is-prop-valid'\nimport hoist from 'hoist-non-react-statics'\nimport React, { Component, createElement } from 'react'\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses'\nimport determineTheme from '../utils/determineTheme'\nimport escape from '../utils/escape'\n\nimport generateDisplayName from '../utils/generateDisplayName'\nimport getComponentName from '../utils/getComponentName'\nimport isStyledComponent from '../utils/isStyledComponent'\nimport isTag from '../utils/isTag'\nimport hasInInheritanceChain from '../utils/hasInInheritanceChain'\nimport StyleSheet from './StyleSheet'\nimport { ThemeConsumer, type Theme } from './ThemeProvider'\nimport { StyleSheetConsumer } from './StyleSheetManager'\nimport { EMPTY_OBJECT } from '../utils/empties'\n\nimport type { RuleSet, Target } from '../types'\n\n// HACK for generating all static styles without needing to allocate\n// an empty execution context every single time...\nconst STATIC_EXECUTION_CONTEXT = {}\n\nconst identifiers = {}\n\n/* We depend on components having unique IDs */\nfunction generateId(\n  ComponentStyle: Function,\n  _displayName: string,\n  parentComponentId: string\n) {\n  const displayName =\n    typeof _displayName !== 'string' ? 'sc' : escape(_displayName)\n\n  /**\n   * This ensures uniqueness if two components happen to share\n   * the same displayName.\n   */\n  const nr = (identifiers[displayName] || 0) + 1\n  identifiers[displayName] = nr\n\n  const componentId = `${displayName}-${ComponentStyle.generateName(\n    displayName + nr\n  )}`\n\n  return parentComponentId !== undefined\n    ? `${parentComponentId}-${componentId}`\n    : componentId\n}\n\n// $FlowFixMe\nclass BaseStyledComponent extends Component<*> {\n  static target: Target\n  static styledComponentId: string\n  static attrs: Object\n  static componentStyle: Object\n  static defaultProps: Object\n  static warnTooManyClasses: Function\n\n  renderOuter: Function\n  renderInner: Function\n  styleSheet: ?StyleSheet\n\n  attrs = {}\n\n  constructor() {\n    super()\n    this.renderOuter = this.renderOuter.bind(this)\n    this.renderInner = this.renderInner.bind(this)\n  }\n\n  render() {\n    return <StyleSheetConsumer>{this.renderOuter}</StyleSheetConsumer>\n  }\n\n  renderOuter(styleSheet?: StyleSheet) {\n    this.styleSheet = styleSheet\n\n    return <ThemeConsumer>{this.renderInner}</ThemeConsumer>\n  }\n\n  renderInner(theme?: Theme) {\n    const { innerRef } = this.props\n    const {\n      styledComponentId,\n      target,\n      defaultProps,\n      componentStyle,\n    } = this.constructor\n\n    const isTargetTag = isTag(target)\n\n    let generatedClassName\n    if (componentStyle.isStatic) {\n      generatedClassName = this.generateAndInjectStyles(\n        STATIC_EXECUTION_CONTEXT,\n        this.props,\n        this.styleSheet\n      )\n    } else if (theme !== undefined) {\n      const determinedTheme = determineTheme(this.props, theme, defaultProps)\n      generatedClassName = this.generateAndInjectStyles(\n        determinedTheme,\n        this.props,\n        this.styleSheet\n      )\n    } else {\n      generatedClassName = this.generateAndInjectStyles(\n        this.props.theme || EMPTY_OBJECT,\n        this.props,\n        this.styleSheet\n      )\n    }\n\n    const className = [\n      this.props.className,\n      styledComponentId,\n      this.attrs.className,\n      generatedClassName,\n    ]\n      .filter(Boolean)\n      .join(' ')\n\n    const baseProps: Object = {\n      ...this.attrs,\n      className,\n    }\n\n    if (isStyledComponent(target)) {\n      baseProps.innerRef = innerRef\n    } else {\n      baseProps.ref = innerRef\n    }\n\n    const propsForElement = baseProps\n\n    let key\n    for (key in this.props) {\n      // Don't pass through non HTML tags through to HTML elements\n      // always omit innerRef\n      if (\n        key !== 'innerRef' &&\n        key !== 'className' &&\n        (!isTargetTag || validAttr(key))\n      ) {\n        propsForElement[key] =\n          key === 'style' && key in this.attrs\n            ? { ...this.attrs[key], ...this.props[key] }\n            : this.props[key]\n      }\n    }\n\n    return createElement(target, propsForElement)\n  }\n\n  buildExecutionContext(theme: any, props: any) {\n    const { attrs } = this.constructor\n    const context = { ...props, theme }\n    if (attrs === undefined) {\n      return context\n    }\n\n    this.attrs = Object.keys(attrs).reduce((acc, key) => {\n      const attr = attrs[key]\n\n      // eslint-disable-next-line no-param-reassign\n      acc[key] =\n        typeof attr === 'function' && !hasInInheritanceChain(attr, Component)\n          ? attr(context)\n          : attr\n      return acc\n    }, {})\n\n    return { ...context, ...this.attrs }\n  }\n\n  generateAndInjectStyles(\n    theme: any,\n    props: any,\n    styleSheet: ?StyleSheet = StyleSheet.master\n  ) {\n    const { attrs, componentStyle, warnTooManyClasses } = this.constructor\n\n    // statically styled-components don't need to build an execution context object,\n    // and shouldn't be increasing the number of class names\n    if (componentStyle.isStatic && attrs === undefined) {\n      return componentStyle.generateAndInjectStyles(\n        STATIC_EXECUTION_CONTEXT,\n        styleSheet\n      )\n    } else {\n      const executionContext = this.buildExecutionContext(theme, props)\n      const className = componentStyle.generateAndInjectStyles(\n        executionContext,\n        styleSheet\n      )\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        warnTooManyClasses !== undefined\n      ) {\n        warnTooManyClasses(className)\n      }\n\n      return className\n    }\n  }\n}\n\nexport default (ComponentStyle: Function) => {\n  function createStyledComponent(\n    target: Target,\n    options: Object,\n    rules: RuleSet\n  ) {\n    const {\n      isClass = !isTag(target),\n      displayName = generateDisplayName(target),\n      componentId = generateId(\n        ComponentStyle,\n        options.displayName,\n        options.parentComponentId\n      ),\n      ParentComponent = BaseStyledComponent,\n      attrs,\n    } = options\n\n    const styledComponentId =\n      options.displayName && options.componentId\n        ? `${escape(options.displayName)}-${options.componentId}`\n        : options.componentId || componentId\n\n    const componentStyle = new ComponentStyle(rules, attrs, styledComponentId)\n\n    class StyledComponent extends ParentComponent {\n      static attrs = attrs\n      static componentStyle = componentStyle\n      static displayName = displayName\n      static styledComponentId = styledComponentId\n      static target = target\n\n      static withComponent(tag: Target) {\n        const { componentId: previousComponentId, ...optionsToCopy } = options\n\n        const newComponentId =\n          previousComponentId &&\n          `${previousComponentId}-${\n            isTag(tag) ? tag : escape(getComponentName(tag))\n          }`\n\n        const newOptions = {\n          ...optionsToCopy,\n          componentId: newComponentId,\n          ParentComponent: StyledComponent,\n        }\n\n        return createStyledComponent(tag, newOptions, rules)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      StyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName)\n    }\n\n    if (isClass) {\n      // $FlowFixMe\n      hoist(StyledComponent, target, {\n        // all SC-specific things should not be hoisted\n        attrs: true,\n        componentStyle: true,\n        displayName: true,\n        styledComponentId: true,\n        target: true,\n        warnTooManyClasses: true,\n        withComponent: true,\n      })\n    }\n\n    return StyledComponent\n  }\n\n  return createStyledComponent\n}\n","// @flow\nimport hashStr from '../vendor/glamor/hash'\nimport isStaticRules from '../utils/isStaticRules'\nimport type { RuleSet, NameGenerator, Flattener, Stringifier } from '../types'\nimport StyleSheet from './StyleSheet'\nimport { IS_BROWSER } from '../constants'\n\nconst areStylesCacheable = IS_BROWSER\n\nconst isHMREnabled =\n  typeof module !== 'undefined' &&\n  module.hot &&\n  process.env.NODE_ENV !== 'production'\n\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */\nexport default (\n  nameGenerator: NameGenerator,\n  flatten: Flattener,\n  stringifyRules: Stringifier\n) => {\n  /* combines hashStr (murmurhash) and nameGenerator for convenience */\n  const generateRuleHash = (str: string) => nameGenerator(hashStr(str))\n\n  class ComponentStyle {\n    rules: RuleSet\n    componentId: string\n    isStatic: boolean\n    lastClassName: ?string\n\n    constructor(rules: RuleSet, attrs?: Object, componentId: string) {\n      this.rules = rules\n      this.isStatic = !isHMREnabled && isStaticRules(rules, attrs)\n      this.componentId = componentId\n\n      if (!StyleSheet.master.hasId(componentId)) {\n        const placeholder =\n          process.env.NODE_ENV !== 'production' ? [`.${componentId} {}`] : []\n\n        StyleSheet.master.deferredInject(componentId, placeholder)\n      }\n    }\n\n    /*\n     * Flattens a rule set into valid CSS\n     * Hashes it, wraps the whole chunk in a .hash1234 {}\n     * Returns the hash to be injected on render()\n     * */\n    generateAndInjectStyles(executionContext: Object, styleSheet: StyleSheet) {\n      const { isStatic, componentId, lastClassName } = this\n      if (\n        areStylesCacheable &&\n        isStatic &&\n        lastClassName !== undefined &&\n        styleSheet.hasNameForId(componentId, ((lastClassName: any): string))\n      ) {\n        return lastClassName\n      }\n\n      const flatCSS = flatten(this.rules, executionContext, styleSheet)\n      const name = generateRuleHash(this.componentId + flatCSS.join(''))\n      if (!styleSheet.hasNameForId(componentId, name)) {\n        styleSheet.inject(\n          this.componentId,\n          stringifyRules(flatCSS, `.${name}`),\n          name\n        )\n      }\n\n      this.lastClassName = name\n      return name\n    }\n\n    static generateName(str: string): string {\n      return generateRuleHash(str)\n    }\n  }\n\n  return ComponentStyle\n}\n","// @flow\nimport type { Target } from '../types'\nimport domElements from '../utils/domElements'\n\nexport default (styledComponent: Function, constructWithOptions: Function) => {\n  const styled = (tag: Target) => constructWithOptions(styledComponent, tag)\n\n  // Shorthands for all valid HTML Elements\n  domElements.forEach(domElement => {\n    styled[domElement] = styled(domElement)\n  })\n\n  return styled\n}\n","// @flow\nimport hashStr from '../vendor/glamor/hash'\nimport type { Interpolation, NameGenerator, Stringifier } from '../types'\nimport Keyframes from '../models/Keyframes'\n\nconst replaceWhitespace = (str: string): string => str.replace(/\\s|\\\\n/g, '')\n\ntype KeyframesFn = (\n  strings: Array<string>,\n  ...interpolations: Array<Interpolation>\n) => Keyframes\n\nexport default (\n  nameGenerator: NameGenerator,\n  stringifyRules: Stringifier,\n  css: Function\n): KeyframesFn => (...arr): Keyframes => {\n  const rules = css(...arr)\n  const name = nameGenerator(hashStr(replaceWhitespace(JSON.stringify(rules))))\n\n  return new Keyframes(name, stringifyRules(rules, name, '@keyframes'))\n}\n","// @flow\nimport type { RuleSet, Stringifier } from '../types'\nimport flatten from '../utils/flatten'\nimport isStaticRules from '../utils/isStaticRules'\nimport StyleSheet from './StyleSheet'\n\nexport default (ComponentStyle: Function, stringifyRules: Stringifier) => {\n  class GlobalStyle {\n    rules: RuleSet\n    componentId: string\n    isStatic: boolean\n\n    constructor(rules: RuleSet, componentId: string) {\n      this.rules = rules\n      this.componentId = componentId\n      this.isStatic = isStaticRules(rules)\n      if (!StyleSheet.master.hasId(componentId)) {\n        StyleSheet.master.deferredInject(componentId, [])\n      }\n    }\n\n    createStyles(executionContext: Object, styleSheet: StyleSheet) {\n      const flatCSS = flatten(this.rules, executionContext)\n      const css = stringifyRules(flatCSS, '')\n      // TODO: We will need to figure out how to do this before 4.0\n      // const name = ComponentStyle.generateName(this.componentId + css)\n      styleSheet.inject(this.componentId, css, '')\n    }\n\n    renderStyles(executionContext: Object, styleSheet: StyleSheet) {\n      this.removeStyles(styleSheet)\n      this.createStyles(executionContext, styleSheet)\n    }\n\n    removeStyles(styleSheet: StyleSheet) {\n      const { componentId } = this\n      if (styleSheet.hasId(componentId)) {\n        styleSheet.remove(componentId)\n      }\n    }\n  }\n\n  return GlobalStyle\n}\n","// @flow\nimport React from 'react'\nimport { STATIC_EXECUTION_CONTEXT } from '../constants'\nimport _GlobalStyle from '../models/GlobalStyle'\nimport StyleSheet from '../models/StyleSheet'\nimport { StyleSheetConsumer } from '../models/StyleSheetManager'\nimport StyledError from '../utils/error'\nimport determineTheme from '../utils/determineTheme'\nimport { ThemeConsumer, type Theme } from '../models/ThemeProvider'\nimport type { CSSConstructor, Interpolation, Stringifier } from '../types'\nimport hashStr from '../vendor/glamor/hash'\n\nexport default (\n  ComponentStyle: Function,\n  stringifyRules: Stringifier,\n  css: CSSConstructor\n) => {\n  const GlobalStyle = _GlobalStyle(ComponentStyle, stringifyRules)\n\n  const createGlobalStyle = (\n    strings: Array<string>,\n    ...interpolations: Array<Interpolation>\n  ) => {\n    const rules = css(strings, ...interpolations)\n    const id = `sc-global-${hashStr(JSON.stringify(rules))}`\n    const style = new GlobalStyle(rules, id)\n    class GlobalStyleComponent extends React.Component<*, *> {\n      componentWillUnmount() {\n        const { sheet } = this.props\n        style.removeStyles(sheet)\n      }\n      render() {\n        const { sheet, context } = this.props\n        style.renderStyles(context, sheet)\n        return null\n      }\n    }\n\n    class GlobalStyleComponentManager extends React.Component<*, *> {\n      static defaultProps: Object\n\n      static styledComponentId = id\n\n      render() {\n        if (process.env.NODE_ENV !== 'production') {\n          if (typeof this.props.children !== 'undefined') {\n            throw new StyledError(11)\n          }\n        }\n\n        return (\n          <StyleSheetConsumer>\n            {(styleSheet?: StyleSheet) => {\n              if (style.isStatic) {\n                return (\n                  <GlobalStyleComponent\n                    sheet={styleSheet || StyleSheet.master}\n                    context={STATIC_EXECUTION_CONTEXT}\n                  />\n                )\n              } else {\n                return (\n                  <ThemeConsumer>\n                    {(theme?: Theme) => {\n                      const { defaultProps } = this.constructor\n                      let context = {\n                        ...this.props,\n                      }\n                      if (typeof theme !== 'undefined') {\n                        const determinedTheme = determineTheme(\n                          this.props,\n                          theme,\n                          defaultProps\n                        )\n                        // $FlowFixMe TODO: flow for optional styleSheet\n                        context = {\n                          theme: determinedTheme,\n                          ...context,\n                        }\n                      }\n                      return (\n                        <GlobalStyleComponent\n                          sheet={styleSheet || StyleSheet.master}\n                          context={context}\n                        />\n                      )\n                    }}\n                  </ThemeConsumer>\n                )\n              }\n            }}\n          </StyleSheetConsumer>\n        )\n      }\n    }\n\n    // TODO: Use internal abstractions to avoid additional component layers\n    // Depends on a future overall refactoring of theming system / context\n    return GlobalStyleComponentManager\n  }\n\n  return createGlobalStyle\n}\n"],"names":["Object","create","attrs","render","styleSheet"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDC;;CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAuFiBA,aAAA,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBA+GAA,aAAA,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAuFkCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gGA4F/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBCvaH,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACID;;CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCCoBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC0BAC;;;;;;;gCAQAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCCpCE,OAAA,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DA6B6DC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvD3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACSxB;;;;;;;CAAA;;;ACTsC;;;8BAOhD,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yECOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}