{"version":3,"file":"styled-components.native.cjs.js","sources":["../src/models/StyleTags.js","../src/models/Keyframes.js","../src/models/InlineStyle.js","../src/models/ThemeProvider.js","../src/models/StyledNativeComponent.js"],"sourcesContent":["// @flow\n/* eslint-disable flowtype/object-type-delimiter */\n/* eslint-disable react/prop-types */\n\nimport React, { type Element } from 'react'\nimport {\n  IS_BROWSER,\n  DISABLE_SPEEDY,\n  SC_ATTR,\n  SC_VERSION_ATTR,\n} from '../constants'\nimport StyledError from '../utils/error'\nimport { type ExtractedComp } from '../utils/extractCompsFromCSS'\nimport { splitByRules } from '../utils/stringifyRules'\nimport getNonce from '../utils/nonce'\nimport once from '../utils/once'\n\nimport {\n  type Names,\n  addNameForId,\n  resetIdNames,\n  hasNameForId,\n  stringifyNames,\n  cloneNames,\n} from '../utils/styleNames'\n\nimport {\n  sheetForTag,\n  safeInsertRule,\n  deleteRules,\n} from '../utils/insertRuleHelpers'\n\ndeclare var __VERSION__: string\n\nexport interface Tag<T> {\n  // $FlowFixMe: Doesn't seem to accept any combination w/ HTMLStyleElement for some reason\n  styleTag: HTMLStyleElement | null;\n  /* lists all ids of the tag */\n  getIds(): string[];\n  /* checks whether `name` is already injected for `id` */\n  hasNameForId(id: string, name: string): boolean;\n  /* inserts a marker to ensure the id's correct position in the sheet */\n  insertMarker(id: string): T;\n  /* inserts rules according to the ids markers */\n  insertRules(id: string, cssRules: string[], name: ?string): void;\n  /* removes all rules belonging to the id, keeping the marker around */\n  removeRules(id: string): void;\n  css(): string;\n  toHTML(additionalAttrs: ?string): string;\n  toElement(): Element<*>;\n  clone(): Tag<T>;\n}\n\n/* this marker separates component styles and is important for rehydration */\nconst makeTextMarker = id => `\\n/* sc-component-id: ${id} */\\n`\n\n/* add up all numbers in array up until and including the index */\nconst addUpUntilIndex = (sizes: number[], index: number): number => {\n  let totalUpToIndex = 0\n  for (let i = 0; i <= index; i += 1) {\n    totalUpToIndex += sizes[i]\n  }\n\n  return totalUpToIndex\n}\n\n/* create a new style tag after lastEl */\nconst makeStyleTag = (\n  target: ?HTMLElement,\n  tagEl: ?Node,\n  insertBefore: ?boolean\n) => {\n  const el = document.createElement('style')\n  el.setAttribute(SC_ATTR, '')\n  el.setAttribute(SC_VERSION_ATTR, __VERSION__)\n\n  const nonce = getNonce()\n  if (nonce) {\n    el.setAttribute('nonce', nonce)\n  }\n\n  /* Work around insertRule quirk in EdgeHTML */\n  el.appendChild(document.createTextNode(''))\n\n  if (target && !tagEl) {\n    /* Append to target when no previous element was passed */\n    target.appendChild(el)\n  } else {\n    if (!tagEl || !target || !tagEl.parentNode) {\n      throw new StyledError(6)\n    }\n\n    /* Insert new style tag after the previous one */\n    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling)\n  }\n\n  return el\n}\n\n/* takes a css factory function and outputs an html styled tag factory */\nconst wrapAsHtmlTag = (css: () => string, names: Names) => (\n  additionalAttrs: ?string\n): string => {\n  const nonce = getNonce()\n  const attrs = [\n    nonce && `nonce=\"${nonce}\"`,\n    `${SC_ATTR}=\"${stringifyNames(names)}\"`,\n    `${SC_VERSION_ATTR}=\"${__VERSION__}\"`,\n    additionalAttrs,\n  ]\n\n  const htmlAttr = attrs.filter(Boolean).join(' ')\n  return `<style ${htmlAttr}>${css()}</style>`\n}\n\n/* takes a css factory function and outputs an element factory */\nconst wrapAsElement = (css: () => string, names: Names) => () => {\n  const props = {\n    [SC_ATTR]: stringifyNames(names),\n    [SC_VERSION_ATTR]: __VERSION__,\n  }\n\n  const nonce = getNonce()\n  if (nonce) {\n    // $FlowFixMe\n    props.nonce = nonce\n  }\n\n  // eslint-disable-next-line react/no-danger\n  return <style {...props} dangerouslySetInnerHTML={{ __html: css() }} />\n}\n\nconst getIdsFromMarkersFactory = (markers: Object) => (): string[] =>\n  Object.keys(markers)\n\n/* speedy tags utilise insertRule */\nconst makeSpeedyTag = (\n  el: HTMLStyleElement,\n  getImportRuleTag: ?() => Tag<any>\n): Tag<number> => {\n  const names: Names = (Object.create(null): Object)\n  const markers = Object.create(null)\n  const sizes: number[] = []\n\n  const extractImport = getImportRuleTag !== undefined\n  /* indicates whther getImportRuleTag was called */\n  let usedImportRuleTag = false\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    markers[id] = sizes.length\n    sizes.push(0)\n    resetIdNames(names, id)\n\n    return markers[id]\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    const sheet = sheetForTag(el)\n    const insertIndex = addUpUntilIndex(sizes, marker)\n\n    let injectedRules = 0\n    const importRules = []\n    const cssRulesSize = cssRules.length\n\n    for (let i = 0; i < cssRulesSize; i += 1) {\n      const cssRule = cssRules[i]\n      let mayHaveImport = extractImport /* @import rules are reordered to appear first */\n      if (mayHaveImport && cssRule.indexOf('@import') !== -1) {\n        importRules.push(cssRule)\n      } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {\n        mayHaveImport = false\n        injectedRules += 1\n      }\n    }\n\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true\n      // $FlowFixMe\n      getImportRuleTag().insertRules(`${id}-import`, importRules)\n    }\n\n    sizes[marker] += injectedRules /* add up no of injected rules */\n    addNameForId(names, id, name)\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n\n    const size = sizes[marker]\n    const sheet = sheetForTag(el)\n    const removalIndex = addUpUntilIndex(sizes, marker)\n    deleteRules(sheet, removalIndex, size)\n    sizes[marker] = 0\n    resetIdNames(names, id)\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(`${id}-import`)\n    }\n  }\n\n  const css = () => {\n    const { cssRules } = sheetForTag(el)\n    let str = ''\n\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      str += makeTextMarker(id)\n      const marker = markers[id]\n      const end = addUpUntilIndex(sizes, marker)\n      const size = sizes[marker]\n      for (let i = end - size; i < end; i += 1) {\n        const rule = cssRules[i]\n        if (rule !== undefined) {\n          str += rule.cssText\n        }\n      }\n    }\n\n    return str\n  }\n\n  return {\n    styleTag: el,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    css,\n    toHTML: wrapAsHtmlTag(css, names),\n    toElement: wrapAsElement(css, names),\n    clone() {\n      throw new StyledError(5)\n    },\n  }\n}\n\nconst makeTextNode = id => document.createTextNode(makeTextMarker(id))\n\nconst makeBrowserTag = (\n  el: HTMLStyleElement,\n  getImportRuleTag: ?() => Tag<any>\n): Tag<Text> => {\n  const names = (Object.create(null): Object)\n  const markers = Object.create(null)\n\n  const extractImport = getImportRuleTag !== undefined\n\n  /* indicates whther getImportRuleTag was called */\n  let usedImportRuleTag = false\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    markers[id] = makeTextNode(id)\n    el.appendChild(markers[id])\n    names[id] = Object.create(null)\n\n    return markers[id]\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    const importRules = []\n    const cssRulesSize = cssRules.length\n\n    for (let i = 0; i < cssRulesSize; i += 1) {\n      const rule = cssRules[i]\n      let mayHaveImport = extractImport\n      if (mayHaveImport && rule.indexOf('@import') !== -1) {\n        importRules.push(rule)\n      } else {\n        mayHaveImport = false\n        const separator = i === cssRulesSize - 1 ? '' : ' '\n        marker.appendData(`${rule}${separator}`)\n      }\n    }\n    addNameForId(names, id, name)\n    if (extractImport && importRules.length > 0) {\n      usedImportRuleTag = true\n      // $FlowFixMe\n      getImportRuleTag().insertRules(`${id}-import`, importRules)\n    }\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n\n    /* create new empty text node and replace the current one */\n    const newMarker = makeTextNode(id)\n    el.replaceChild(newMarker, marker)\n    markers[id] = newMarker\n    resetIdNames(names, id)\n\n    if (extractImport && usedImportRuleTag) {\n      // $FlowFixMe\n      getImportRuleTag().removeRules(`${id}-import`)\n    }\n  }\n\n  const css = () => {\n    let str = ''\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      str += markers[id].data\n    }\n    return str\n  }\n  return {\n    clone() {\n      throw new StyledError(5)\n    },\n    css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    styleTag: el,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names),\n  }\n}\n\nconst makeServerTagInternal = (namesArg, markersArg): Tag<[string]> => {\n  const names =\n    namesArg === undefined ? (Object.create(null): Object) : namesArg\n  const markers = markersArg === undefined ? Object.create(null) : markersArg\n\n  const insertMarker = id => {\n    const prev = markers[id]\n    if (prev !== undefined) {\n      return prev\n    }\n\n    return (markers[id] = [''])\n  }\n\n  const insertRules = (id, cssRules, name) => {\n    const marker = insertMarker(id)\n    marker[0] += cssRules.join(' ')\n    addNameForId(names, id, name)\n  }\n\n  const removeRules = id => {\n    const marker = markers[id]\n    if (marker === undefined) return\n    marker[0] = ''\n    resetIdNames(names, id)\n  }\n\n  const css = () => {\n    let str = ''\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      const cssForId = markers[id][0]\n      if (cssForId) {\n        str += makeTextMarker(id) + cssForId\n      }\n    }\n    return str\n  }\n\n  const clone = () => {\n    const namesClone = cloneNames(names)\n    const markersClone = Object.create(null)\n\n    // eslint-disable-next-line guard-for-in\n    for (const id in markers) {\n      markersClone[id] = [markers[id][0]]\n    }\n\n    return makeServerTagInternal(namesClone, markersClone)\n  }\n\n  const tag = {\n    clone,\n    css,\n    getIds: getIdsFromMarkersFactory(markers),\n    hasNameForId: hasNameForId(names),\n    insertMarker,\n    insertRules,\n    removeRules,\n    styleTag: null,\n    toElement: wrapAsElement(css, names),\n    toHTML: wrapAsHtmlTag(css, names),\n  }\n\n  return tag\n}\n\nconst makeServerTag = (): Tag<[string]> => makeServerTagInternal()\n\nexport const makeTag = (\n  target: ?HTMLElement,\n  tagEl: ?HTMLStyleElement,\n  forceServer?: boolean,\n  insertBefore?: boolean,\n  getImportRuleTag?: () => Tag<any>\n): Tag<any> => {\n  if (IS_BROWSER && !forceServer) {\n    const el = makeStyleTag(target, tagEl, insertBefore)\n\n    if (DISABLE_SPEEDY) {\n      return makeBrowserTag(el, getImportRuleTag)\n    } else {\n      return makeSpeedyTag(el, getImportRuleTag)\n    }\n  }\n\n  return makeServerTag()\n}\n\n/* wraps a given tag so that rehydration is performed once when necessary */\nexport const makeRehydrationTag = (\n  tag: Tag<any>,\n  els: HTMLStyleElement[],\n  extracted: ExtractedComp[],\n  immediateRehydration: boolean\n): Tag<any> => {\n  /* rehydration function that adds all rules to the new tag */\n  const rehydrate = once(() => {\n    /* add all extracted components to the new tag */\n    for (let i = 0, len = extracted.length; i < len; i += 1) {\n      const { componentId, cssFromDOM } = extracted[i]\n      const cssRules = splitByRules(cssFromDOM)\n      tag.insertRules(componentId, cssRules)\n    }\n\n    /* remove old HTMLStyleElements, since they have been rehydrated */\n    for (let i = 0, len = els.length; i < len; i += 1) {\n      const el = els[i]\n      if (el.parentNode) {\n        el.parentNode.removeChild(el)\n      }\n    }\n  })\n\n  if (immediateRehydration) rehydrate()\n\n  return {\n    ...tag,\n    /* add rehydration hook to insertion methods */\n    insertMarker: id => {\n      rehydrate()\n      return tag.insertMarker(id)\n    },\n    insertRules: (id, cssRules, name) => {\n      rehydrate()\n      return tag.insertRules(id, cssRules, name)\n    },\n  }\n}\n","// @flow\nimport StyleSheet from '../models/StyleSheet'\n\nexport default class Keyframes {\n  id: string\n  name: string\n  rules: Array<string>\n\n  constructor(name: string, rules: Array<string>) {\n    this.name = name\n    this.rules = rules\n\n    this.id = `sc-keyframes-${name}`\n  }\n\n  inject = (styleSheet: StyleSheet) => {\n    if (!styleSheet.hasNameForId(this.id, this.name)) {\n      styleSheet.inject(this.id, this.rules, this.name)\n    }\n  }\n\n  getName() {\n    return this.name\n  }\n}\n","// @flow\n/* eslint-disable import/no-unresolved */\nimport transformDeclPairs from 'css-to-react-native'\n\nimport hashStr from '../vendor/glamor/hash'\nimport type { RuleSet, StyleSheet } from '../types'\nimport flatten from '../utils/flatten'\nimport parse from '../vendor/postcss-safe-parser/parse'\n\nlet generated = {}\n\nexport const resetStyleCache = () => {\n  generated = {}\n}\n\n/*\n InlineStyle takes arbitrary CSS and generates a flat object\n */\nexport default (styleSheet: StyleSheet) => {\n  class InlineStyle {\n    rules: RuleSet\n\n    constructor(rules: RuleSet) {\n      this.rules = rules\n    }\n\n    generateStyleObject(executionContext: Object) {\n      const flatCSS = flatten(this.rules, executionContext).join('')\n      const hash = hashStr(flatCSS)\n      if (!generated[hash]) {\n        const root = parse(flatCSS)\n        const declPairs = []\n        root.each(node => {\n          if (node.type === 'decl') {\n            declPairs.push([node.prop, node.value])\n          } else if (\n            node.type !== 'comment' &&\n            process.env.NODE_ENV !== 'production'\n          ) {\n            /* eslint-disable no-console */\n            console.warn(\n              `Node of type ${node.type} not supported as an inline style`\n            )\n          }\n        })\n        // RN currently does not support differing values for the corner radii of Image\n        // components (but does for View). It is almost impossible to tell whether we'll have\n        // support, so we'll just disable multiple values here.\n        // https://github.com/styled-components/css-to-react-native/issues/11\n        const styleObject = transformDeclPairs(declPairs, [\n          'borderRadius',\n          'borderWidth',\n          'borderColor',\n          'borderStyle',\n        ])\n        const styles = styleSheet.create({\n          generated: styleObject,\n        })\n        generated[hash] = styles.generated\n      }\n      return generated[hash]\n    }\n  }\n\n  return InlineStyle\n}\n","// @flow\nimport React, { createContext, Component, type Element } from 'react'\nimport memoize from 'memoize-one'\nimport StyledError from '../utils/error'\n\nexport type Theme = { [key: string]: mixed }\ntype Props = {\n  children?: Element<any>,\n  theme: Theme | ((outerTheme: Theme) => void),\n}\n\nconst isFunction = test => typeof test === 'function'\n\nconst ThemeContext = createContext()\n\nexport const ThemeConsumer = ThemeContext.Consumer\n\n/**\n * Provide a theme to an entire react component tree via context\n */\nexport default class ThemeProvider extends Component<Props> {\n  getContext: (\n    theme: Theme | ((outerTheme: Theme) => void),\n    outerTheme?: Theme\n  ) => Theme\n\n  constructor(props: Props) {\n    super(props)\n    this.getContext = memoize(this.getContext.bind(this))\n  }\n\n  render() {\n    const { children, theme } = this.props\n\n    if (!children) {\n      return null\n    }\n\n    return (\n      <ThemeContext.Consumer>\n        {(outerTheme?: Theme) => {\n          const context = this.getContext(theme, outerTheme)\n\n          return (\n            <ThemeContext.Provider value={context}>\n              {React.Children.only(children)}\n            </ThemeContext.Provider>\n          )\n        }}\n      </ThemeContext.Consumer>\n    )\n  }\n\n  // Get the theme from the props, supporting both (outerTheme) => {} as well as object notation\n  getTheme(theme: (outerTheme: ?Theme) => void, outerTheme: ?Theme) {\n    if (isFunction(theme)) {\n      const mergedTheme = theme(outerTheme)\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (mergedTheme === null ||\n          Array.isArray(mergedTheme) ||\n          typeof mergedTheme !== 'object')\n      ) {\n        throw new StyledError(7)\n      }\n\n      return mergedTheme\n    }\n\n    if (theme === null || Array.isArray(theme) || typeof theme !== 'object') {\n      throw new StyledError(8)\n    }\n\n    return { ...outerTheme, ...(theme: Theme) }\n  }\n\n  getContext(theme: (outerTheme: ?Theme) => void, outerTheme?: Theme) {\n    return this.getTheme(theme, outerTheme)\n  }\n}\n","// @flow\nimport hoist from 'hoist-non-react-statics'\nimport React, { Component, createElement } from 'react'\nimport determineTheme from '../utils/determineTheme'\nimport { EMPTY_OBJECT } from '../utils/empties'\nimport generateDisplayName from '../utils/generateDisplayName'\nimport isStyledComponent from '../utils/isStyledComponent'\nimport isTag from '../utils/isTag'\nimport hasInInheritanceChain from '../utils/hasInInheritanceChain'\nimport { ThemeConsumer } from './ThemeProvider'\n\nimport type { Theme } from './ThemeProvider'\nimport type { RuleSet, Target } from '../types'\n\n// $FlowFixMe\nclass BaseStyledNativeComponent extends Component<*, *> {\n  static target: Target\n  static styledComponentId: string\n  static attrs: Object\n  static defaultProps: Object\n  static inlineStyle: Object\n  root: ?Object\n\n  attrs = {}\n\n  render() {\n    return (\n      <ThemeConsumer>\n        {(theme?: Theme) => {\n          const { style } = this.props\n          const { target, defaultProps } = this.constructor\n\n          let generatedStyles\n          if (theme !== undefined) {\n            const themeProp = determineTheme(this.props, theme, defaultProps)\n            generatedStyles = this.generateAndInjectStyles(\n              themeProp,\n              this.props\n            )\n          } else {\n            generatedStyles = this.generateAndInjectStyles(\n              theme || EMPTY_OBJECT,\n              this.props\n            )\n          }\n\n          const propsForElement = {\n            ...this.attrs,\n            ...this.props,\n            style: [generatedStyles, style],\n          }\n\n          if (\n            !isStyledComponent(target) &&\n            // NOTE: We can't pass a ref to a stateless functional component\n            (typeof target !== 'function' ||\n              // $FlowFixMe TODO: flow for prototype\n              (target.prototype && 'isReactComponent' in target.prototype))\n          ) {\n            propsForElement.ref = this.onRef\n            delete propsForElement.innerRef\n          } else {\n            propsForElement.innerRef = this.onRef\n          }\n\n          return createElement(target, propsForElement)\n        }}\n      </ThemeConsumer>\n    )\n  }\n\n  buildExecutionContext(theme: any, props: any) {\n    const { attrs } = this.constructor\n    const context = { ...props, theme }\n    if (attrs === undefined) {\n      return context\n    }\n\n    this.attrs = Object.keys(attrs).reduce((acc, key) => {\n      const attr = attrs[key]\n      // eslint-disable-next-line no-param-reassign\n      acc[key] =\n        typeof attr === 'function' && !hasInInheritanceChain(attr, Component)\n          ? attr(context)\n          : attr\n      return acc\n    }, {})\n\n    return { ...context, ...this.attrs }\n  }\n\n  generateAndInjectStyles(theme: any, props: any) {\n    const { inlineStyle } = this.constructor\n    const executionContext = this.buildExecutionContext(theme, props)\n\n    return inlineStyle.generateStyleObject(executionContext)\n  }\n\n  setNativeProps(nativeProps: Object) {\n    if (this.root !== undefined) {\n      // $FlowFixMe\n      this.root.setNativeProps(nativeProps)\n    } else if (process.env.NODE_ENV !== 'production') {\n      const { displayName } = this.constructor\n\n      // eslint-disable-next-line no-console\n      console.warn(\n        'setNativeProps was called on a Styled Component wrapping a stateless functional component. ' +\n          'In this case no ref will be stored, and instead an innerRef prop will be passed on.\\n' +\n          `Check whether the stateless functional component is passing on innerRef as a ref in ${displayName ||\n            'UnknownStyledNativeComponent'}.`\n      )\n    }\n  }\n\n  onRef = (node: any) => {\n    // eslint-disable-next-line react/prop-types\n    const { innerRef } = this.props\n    this.root = node\n\n    if (typeof innerRef === 'function') {\n      innerRef(node)\n    } else if (\n      typeof innerRef === 'object' &&\n      innerRef &&\n      innerRef.hasOwnProperty('current')\n    ) {\n      innerRef.current = node\n    }\n  }\n}\n\nexport default (InlineStyle: Function) => {\n  const createStyledNativeComponent = (\n    target: Target,\n    options: Object,\n    rules: RuleSet\n  ) => {\n    const {\n      isClass = !isTag(target),\n      displayName = generateDisplayName(target),\n      ParentComponent = BaseStyledNativeComponent,\n      attrs,\n    } = options\n\n    const inlineStyle = new InlineStyle(rules)\n\n    class StyledNativeComponent extends ParentComponent {\n      static attrs = attrs\n      static displayName = displayName\n      static inlineStyle = inlineStyle\n      static styledComponentId = 'StyledNativeComponent'\n      static target = target\n\n      static withComponent(tag: Target) {\n        const { displayName: _, componentId: __, ...optionsToCopy } = options\n        const newOptions = {\n          ...optionsToCopy,\n          ParentComponent: StyledNativeComponent,\n        }\n        return createStyledNativeComponent(tag, newOptions, rules)\n      }\n    }\n\n    if (isClass) {\n      // $FlowFixMe\n      hoist(StyledNativeComponent, target, {\n        // all SC-specific things should not be hoisted\n        attrs: true,\n        displayName: true,\n        inlineStyle: true,\n        styledComponentId: true,\n        target: true,\n        withComponent: true,\n      })\n    }\n\n    return StyledNativeComponent\n  }\n\n  return createStyledNativeComponent\n}\n"],"names":["Object","create","render"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDC;;CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAuFiBA,aAAA,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBA+GAA,aAAA,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAuFkCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gGA4F/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBCvaH,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BCeE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXH;;CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCCQCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}